---
title: "Progetto di FP&S: Spotify Top Tracks Dataset"
author: "Riccardo Cervero"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

#Progetto di FP&S: Spotify Top Tracks Dataset
```{r}
##Caricamento pacchetti
library(plyr)
library(dplyr)
library(purrr)
library(ggplot2)
library(memisc)
library(e1071)
library(EnvStats)
library(reshape2)
library(car)
library(broom)

##Funzioni

#Calcolo della moda
moda <- function(x) {return(unique(x)[which.max(tabulate(match(x, unique(x))))])}

#Calcolo dell'indice di Gini normalizzato
G_normalizzato <- function(x){
  G=1-sum((table(x)/length(x))^2)
  n=length(unique(x))
  return(G*(n/(n-1)))
}

#Raggruppamento delle osservazioni per decenni
to_decade <- function(v){return(v-v%%10)}

#Calcolo del coefficiente di variazione
cv <- function(x){return(sd(x)/abs(mean(x)))}

#Calcolo della simmetria
m3 <- function(x){return(skewness(x,na.rm=T))}

#Calcolo della curtosi
m4 <- function(x){return(kurtosis(x,na.rm=T,method="moment",excess=F))}


#Analisi preliminare di una qualsiasi variabile numerica
AnPrel <- function(col) {
  
  #Statistiche preliminari
  s<-summary(col)
  stat <- c()
  for(i in 1:6) {stat<-c(stat,s[[i]])}
  #Moda
  m<-moda(col)
  #Varianza
  v<-var(col)
  #Coefficiente di variazione
  ccv<-cv(col)
  #Asimmetria
  as<-m3(col)
  if_Z <- function(){if(as==0){return("simmetrica")}else if(as>0){return("asimmetrica positiva")}else if(as<0){return("asimmetrica negativa")}}
  #Curtosi
  cu<-m4(col)
  if_C <- function(){if(cu==3){return("normale.")}else if(cu>3){return("leptocurtica.")}else if(cu<3){return("platicurtica.")}}
  
  stat<-c(stat,m,v,ccv,as,cu)
  indici <- c("Minimo","1o Qu.","Mediana","Media","3o Qu.","Massimo","Moda","Varianza","CdV","Asimmetria","Curtosi")
  stat <- data.frame(cbind(indici,stat))
  names(stat) <- c("Statistica","Valore")
  
  #Grafico della distribuzione
  if((typeof(col)=="double")||(col=db$duration_ms)){
    g<-ggplot(db, aes(x=col))+
      geom_histogram(binwidth = 0.01, color= "red", fill="white")+
      geom_vline(aes(xintercept=mean(col)),color="blue", linetype="dashed", size=0.5)+
      geom_vline(aes(xintercept=median(col)),color="green", linetype="dashed", size=0.5)+
      ylab(label="")+
      xlab(label=substring(deparse(substitute(col)), 4))+
      labs(title=paste("Distribuzione di frequenza di",substring(deparse(substitute(col)), 4)),caption="Le linee verticali tratteggiate corrispondono a media (in blue) e mediana (in verde).")
           } else if(typeof(col)=="integer"){
             g<-ggplot(db, aes(x=col))+
               geom_bar(binwidth = 0.01, color= "red", fill="white")+
               geom_vline(aes(xintercept=mean(col)),color="blue",linetype="dashed", size=0.5)+
               geom_vline(aes(xintercept=median(col)),color="green", linetype="dashed", size=0.5)+
               ylab(label="")+
               xlab(label=substring(deparse(substitute(col)), 4))+
               labs(title=paste("Distribuzione di frequenza di",substring(deparse(substitute(col)), 4)),caption="Le linee verticali tratteggiate corrispondono a media (in blue) e mediana (in verde).")
           }
  
  print(paste("La distribuzione è",if_Z(),"e",if_C()))
  return(list("stat"=stat,
              "distr"=g,
              "qqnorm"=function(){
    qqnorm(col)
    qqline(col)
  }))
}


#Funzione per inferenza della media di una v quantitativa
ICmedia <- function(col,l=0.95){
  n <- nrow(db)
  mu <- mean(col)
  sds <- sd(col)
  E <- qnorm(l+(1-l)/2)*sds/sqrt(n)
  return(c(mu-E, mu+E))
}

#Funzione per il test della correlazione lineare di Pearson (95%)
rhotest<-function(x,y){
  r<-cor.test(x,y,method="pearson")
  if(r$p.value>0.05){print("H0 accettata")}else{print("H0 rifiutata (corr. significativa)")}
  print(paste0("pvalue: ",r$p.value))
  print(paste0("rho: ",r$estimate))
}
```

Il database è disponibile al link [kaggle/spotify-dataset](https://www.kaggle.com/yamaerenay/spotify-dataset-19212020-160k-tracks). La documentazione ufficiale è disponibile al link [spotify/documentation](https://developer.spotify.com/documentation/web-api/reference/tracks/get-audio-features/).
```{r}
#Caricamento del dataset
db_ <- read.csv("/Users/riccardocervero/Desktop/DataScience/Materie/Foundation of Prob & Stats/Progetto FPS - Riccardo Cervero/SpotifyDb.csv")
```
```{r}
#Caricamento database ridotto
db <- read.csv("/Users/riccardocervero/Desktop/DataScience/Materie/Foundation of Prob & Stats/Progetto FPS - Riccardo Cervero/SpotifyRidotto.csv")
db <- db[ , !(colnames(db) %in% c("X")), drop=FALSE]
```
```{r}
#Dimensione del dataset
dim(db)
```
```{r}
#Variabili: nome, tipologia e numero di modalità
for (c in colnames(db)){
 print(paste0(c," : ",typeof(db[[c]]),", ",length(unique(db[[c]])))) 
}
```
* Acousticness è misura numerica di confidenza con cui è possibile definire "acustica" una traccia, compresa fra 0 e 1: se 1, indica massima certezza nell'affermare che il brano sia stato prodotto senza mezzi elettronici
* Artists è la lista degli artisti a cui è attribuita la produzione del brano 
* Danceability descrive il grado - misurato fra 0 e 1 - in cui la traccia può essere definita ballabile, come combinazione di vari elementi musicali, tra cui il tempo, la stabilità del ritmo, la forza del battito e la regolarità globale del brano: se 1, il pezzo raggiunge il massimo livello di ballabilità
* Duration_ms è la durata in millisecondi
* Energy rappresenta la percentuale di intensità e attività della traccia, sulla base di elementi percettivi quali sonorità, timbro, ed entropia globale
* Explicit è una variabile binaria che rileva la presenza - quando pari a 1 - o meno di contenuto esplicito
* Id è l'identificatore primario della traccia 
* Instrumentalness misura, fra 0 e 1, l'assenza di contenuto vocale: più il valore si avvicina a 1, maggiore è la confidenza con cui è possibile definire "strumentale" la traccia
* Key registra la stima della chiave complessiva della traccia, codificata in un valore numerico compreso fra 0 (Do) e 11 (Si) 
* Liveness rileva la presenza di un pubblico udibile nella registrazione, definendone la probabilità: se superiore a 0,8, fornisce una forte evidenza che la traccia sia stata registrata live
* Loudness è il volume complessivo in decibel, fra -60 e circa 4
* Mode è la variabile binaria di modalità del brano: 1 se maggiore e 0 se minore
* Name è il nome del brano
* Release_date è la data di uscita in formato aaa-mm-gg, aaaa-mm o aaaa 
* Speechiness indica la presenza di parlato: maggiore la somiglianza tra la traccia e un discorso - come nel caso del rap -, maggiore la vicinanza del valore a 1
* Tempo è il ritmo misurato in battiti al minuto (bpm)
* Valence definisce il grado di positività emotiva trasmessa dal brano, tra 0 e 1
* Year è l'anno di uscita, dal 1921 al 2020
* Popularity è una variabile intera compresa fra 0 e 100 che esprime il grado di popolarità del brano, calcolato a partire dal numero totale di riproduzioni su Spotify e da quanto sono recenti tali ascolti: in generale, tracce riprodotte molto frequente durante l'anno corrente avranno un valore di popolarità molto elevato
Quest'ultima verrà considerata come principale variabile target nell'ambito della costruzione di modelli di regressione.

##Pre-Processing
```{r}
#Rimozione delle variabili inutili
vi <- c("artists","id","name")
db <- db[ , !(colnames(db) %in% vi), drop=FALSE]
```
```{r}
#Identificazione missing value
db[!complete.cases(db),]
#Missing values in "key"
any(db$key==-1)
```
```{r}
##Uniformare "release_date"
#Conta i formati
date_format <- c()
for(i in 1:length(release_date)) {
  if(!((class(try(as.Date(release_date[i], format= "%Y-%m-%d")))=="try-error")||(is.na(try(as.Date(release_date[i], format= "%Y-%m-%d")))))) {
  date_format <- c(date_format,"YMD")
} else if(!((class(try(as.Date(release_date[i], format= "%Y-%m")))=="try-error")||(is.na(try(as.Date(release_date[i], format= "%Y-%m")))))) {
  date_format <- c(date_format,"YM")
  } else if(!((class(try(as.Date(release_date[i], format= "%Y")))=="try-error")||(is.na(try(as.Date(release_date[i], format= "%Y")))))) {
  date_format <- c(date_format,"Y")
  }
}

table(date_format)
100*table(date_format)/length(date_format)
```

##Analisi delle variabili qualitative

###Analisi di "Year"
```{r}
#Tabella di frequenza
print("Frequenze relative:")
round(table(db$year)/length(db$year),4)
```
La variabile "year" è multimodale, quindi non ha senso calcolarne la moda.
```{r}
#Indice di Gini
print("Indice di Gini normalizzato:")
G_normalizzato(db$year)
```
La mutabilità del fenomeno tende ad essere massima.
```{r}
#Raggruppamento in decenni
db$decade <- unlist(lapply(db$year,to_decade))
db <- db[ , !(colnames(db) %in% c("release_date","year")), drop=FALSE]
#Tabella di frequenza
print("Frequenze relative:")
round(table(db$decade)/length(db$decade),4)
```
```{r}
#PieChart dei decenni
y <- c()
for(i in 1:length(unique(db$decade))) {y<-c(y,table(db$decade)[[i]])}
data <- data.frame(Decennio=as.factor(unique(db$decade)),value=y)
data$label <- scales::percent(data$value/sum(data$value))
ggplot(data, aes(x="", y=value, fill=Decennio)) +
  geom_bar(stat="identity", width=1) +
  coord_polar("y", start=0)+
  theme_void()
```
```{r}
#Tabella a doppia entrata
table=table(db$decade, db$popularity)
#Indice di connessione delle contingenze
chi=chisq.test(table) 
chi
```
Viene rifiutata l'ipotesi di indipendenza fra le due variabili.
```{r}
#Boxplot condizionato
ggplot(db, aes(x=db$decade, y=db$popularity, group=db$decade)) + 
  geom_boxplot()+
  xlab(label = "Decennio")+
  ylab(label = "Popolarità")+
  scale_x_continuous(breaks = scales::pretty_breaks(n = 11))
```
```{r}
#Test ANOVA per l'uguaglianza delle medie
summary(aov(popularity ~ as.factor(decade), db))
```


###Analisi di "Explicit"
```{r}
print("Frequenze relative:")
round(table(db$explicit)/length(db$explicit),4)
```
```{r}
#Indice di Gini
print("Indice di Gini normalizzato:")
G_normalizzato(db$explicit)
```
L'eterogeneità del fenomeno è ovviamente molto bassa.
```{r}
#PieChart di "explicit"
expl <- mapvalues(db$explicit,c(1,0),c("Sì","No"))
y <- c()
for(i in 1:length(unique(expl))) {y<-c(y,table(expl)[[i]])}
data <- data.frame(Esplicito=as.factor(unique(expl)),value=y)
data$label <- scales::percent(data$value/sum(data$value))
ggplot(data, aes(x="", y=value, fill=Esplicito)) +
  geom_bar(stat="identity", width=1) +
  coord_polar("y", start=0)+
  theme_void()
```
```{r}
#Stima intervallare sulla proporzione di contenuto esplicito (con 𝛼=5%)
p <- unlist(table(db$explicit)/length(db$explicit))[[2]] #Freq relativa di contenuto esplicito
p0 <- unlist(table(db$explicit)/length(db$explicit))[[1]] #Freq relativa di contenuto non esplicito
n <- nrow(db) #Dimensione del campione
l <- 0.95   #Livello di confidenza
c <- l+(1-l)/2  
SE <- sqrt(p*(1-p)/n) #Deviazione standard di p 
E  <- qnorm(c)*SE
IC <- p+c(-E,E) #intervallo di confidenza per p (esplicito)
IC0 <- p0+c(-E,E) #intervallo di confidenza per p (non esplicito)
print(paste0("IC della proporzione di contenuto eplicito:  (",IC[1],", ",IC[2],")"))
print(paste0("IC della proporzione di contenuto non eplicito:  (",IC0[1],", ",IC0[2],")"))
```
```{r}
#Tabella a doppia entrata
table=table(db$explicit, db$popularity)
#Indice di connessione delle contingenze
chi=chisq.test(table) 
chi
```
Viene rifiutata l'ipotesi di indipendenza fra le due variabili.
```{r}
#Boxplot condizionato
ggplot(db, aes(x=mapvalues(db$explicit,c(1,0),c("Sì","No")), y=db$popularity, group=mapvalues(db$explicit,c(1,0),c("Sì","No")))) + 
  geom_boxplot()+
  xlab(label = "Esplicito")+
  ylab(label = "Popolarità")
```
```{r}
#Test ANOVA per l'uguaglianza delle medie
summary(aov(popularity ~ as.factor(explicit), db))
```

###Analisi di "Mode"
```{r}
print("Frequenze relative:")
round(table(db$mode)/length(db$mode),4)
```
```{r}
#Indice di Gini
print("Indice di Gini normalizzato:")
G_normalizzato(db$mode)
```
L'eterogeneità del fenomeno è abbastanza elevata.
```{r}
#PieChart di "mode"
expl <- mapvalues(db$mode,c(1,0),c("Maggiore","Minore"))
y <- c()
for(i in 1:length(unique(expl))) {y<-c(y,table(expl)[[i]])}
data <- data.frame(Modalità=as.factor(unique(expl)),value=y)
data$label <- scales::percent(data$value/sum(data$value))
ggplot(data, aes(x="", y=value, fill=Modalità)) +
  geom_bar(stat="identity", width=1) +
  coord_polar("y", start=0)+
  theme_void()
```
```{r}
#Stima intervallare sulla proporzione della modalità (con 𝛼=5%)
p <- unlist(table(db$mode)/length(db$mode))[[2]] #Freq relativa di tonalità "major"
p0 <- unlist(table(db$mode)/length(db$mode))[[1]] #Freq relativa di tonalità "minor"
n <- nrow(db) #Dimensione del campione
l <- 0.95   #Livello di confidenza
c <- l+(1-l)/2  
SE <- sqrt(p*(1-p)/n) #Deviazione standard di p 
E  <- qnorm(c)*SE
IC <- p+c(-E,E) #intervallo di confidenza per p di "major"
IC0 <- p0+c(-E,E) #intervallo di confidenza per p di "minor"
print(paste0("IC della proporzione di tonalità maggiore:  (",IC[1],", ",IC[2],")"))
print(paste0("IC della proporzione di tonalità minore:  (",IC0[1],", ",IC0[2],")"))
```
```{r}
#Tabella a doppia entrata
table=table(db$mode, db$popularity)
#Indice di connessione delle contingenze
chi=chisq.test(table) 
chi
```
Viene rifiutata l'ipotesi di indipendenza fra le due variabili.
```{r}
#Boxplot condizionato
ggplot(db, aes(x=mapvalues(db$mode,c(1,0),c("Maggiore","Minore")), y=db$popularity, group=mapvalues(db$mode,c(1,0),c("Maggiore","Minore")))) +
  geom_boxplot()+
  xlab(label = "Modalità")+
  ylab(label = "Popolarità")
```
```{r}
#Test ANOVA per l'uguaglianza delle medie
summary(aov(popularity ~ as.factor(mode), db))
```

###Analisi di "Key"
```{r}
#Tabella di frequenza
print("Frequenze relative:")
round(table(db$key)/length(db$key),4)
#Moda
print("Moda:")
moda(db$key)
```
```{r}
#Indice di Gini
print("Indice di Gini normalizzato:")
G_normalizzato(db$key)
```
Il fenomeno è estremamente eterogeneo.
```{r}
#PieChart di "key"
expl <- mapvalues(db$key,c(0,1,2,3,4,5,6,7,8,9,10,11),c("Do","Do♯","Re","Re♯","Mi","Fa","Fa♯","Sol","Sol♯","La","La♯","Si"))
y <- c()
for(i in 1:length(unique(expl))) {y<-c(y,table(expl)[[i]])}
data <- data.frame(Chiave=as.factor(unique(expl)),value=y)
data$label <- scales::percent(data$value/sum(data$value))
ggplot(data, aes(x="", y=value, fill=Chiave)) +
  geom_bar(stat="identity", width=1) +
  coord_polar("y", start=0)+
  theme_void()
```
```{r}
#Stima intervallare sulla proporzione di Do (con 𝛼=5%)
p <- unlist(table(db$key)/length(db$key))[[1]] #Frequenza relativa di Do
n <- nrow(db) #Dimensione del campione
l <- 0.95   #Livello di confidenza
c <- l+(1-l)/2  
SE <- sqrt(p*(1-p)/n) #Deviazione standard di p 
E  <- qnorm(c)*SE
IC <- p+c(-E,E) #intervallo di confidenza per p di "major"
print(paste0("IC della proporzione di tracce in Do:  (",IC[1],", ",IC[2],")"))
```
```{r}
#Do può essere stimata, con confidenza al 95%, come chiave più frequente?
ICp <- function(k){
  p <- unlist(table(db$key)/length(db$key))[[k]]
  n <- nrow(db)
  SE <- sqrt(p*(1-p)/n)
  E  <- qnorm(0.975)*SE
  IC <- p+c(-E,E)
  if(IC[2]>=0.124951684177052){print(paste0(k-1,": TRUE"))}else{print(paste0(k-1,": IC minore rispetto alla classe 'Do'"))}
}
for(k in 2:12){ICp(k)}
```
```{r}
#Tabella a doppia entrata
table=table(db$key, db$popularity)
#Indice di connessione delle contingenze
chi=chisq.test(table) 
chi
```
Viene rifiutata l'ipotesi di indipendenza fra le due variabili.
```{r}
#Boxplot condizionato
ggplot(db, aes(x=mapvalues(db$key,c(0,1,2,3,4,5,6,7,8,9,10,11),c("Do","Do♯","Re","Re♯","Mi","Fa","Fa♯","Sol","Sol♯","La","La♯","Si")), y=db$popularity, group=mapvalues(db$key,c(0,1,2,3,4,5,6,7,8,9,10,11),c("Do","Do♯","Re","Re♯","Mi","Fa","Fa♯","Sol","Sol♯","La","La♯","Si")))) +
  geom_boxplot()+
  xlab(label = "Chiave")+
  ylab(label = "Popolarità")
```
```{r}
#Test ANOVA per l'uguaglianza delle medie
summary(aov(popularity ~ as.factor(key), db))
```

##Analisi delle variabili quantitative

###Analisi di "Acousticness"
```{r}
acoustic <- AnPrel(db$acousticness)
```
```{r}
#Statistiche di base
acoustic$stat
```
```{r}
#Distribuzione
acoustic$distr
```
```{r}
#Normalità
acoustic$qqnorm()
```
```{r}
#Stima intervallare dell'acusticità media dal 1921 ad oggi (al 95%)
ICmedia(db$acousticness)
```
I dati si riferiscono pertanto a tracce con una probabilità media di essere completamente acustiche - stimata con confidenza al 95% - inferiore rispetto alla probabilità media di includere strumenti elettronici, poichè l'intervallo di confidenza di "acousticness" ha estremo superiore inferiore a 0.5.

###Analisi di "Danceability"
```{r}
dance <- AnPrel(db$danceability)
```
```{r}
#Statistiche di base
dance$stat
```
```{r}
#Distribuzione
dance$distr
```
```{r}
#Normalità
dance$qqnorm()
```
```{r}
#Stima intervallare della ballabilità media dal 1921 ad oggi (al 95%)
ICmedia(db$danceability)
```

###Analisi di "Duration_ms"
```{r}
duration <- AnPrel(db$duration_ms)
```
```{r}
#Statistiche di base
duration$stat
```
```{r,include=FALSE,eval=FALSE}
#Distribuzione
duration$distr
```
```{r,include=FALSE,eval=FALSE}
#Normalità
duration$qqnorm()
```
```{r}
#Stima intervallare della durata media dal 1921 ad oggi (al 95%)
ICmedia(db$duration_ms)
```
La stima - con livello di confidenza al 95% - della durata media dei brani è compresa fra circa 3 minuti e 51 secondi e 3 minuti e 52 secondi.

###Analisi di "Energy"
```{r}
ener <- AnPrel(db$energy)
```
```{r}
#Statistiche di base
ener$stat
```
```{r}
#Distribuzione
ener$distr
```
```{r}
#Normalità
ener$qqnorm()
```
```{r}
#Stima intervallare dell'energia media dal 1921 ad oggi (al 95%)
ICmedia(db$energy)
```

###Analisi di "Instrumentalness"
```{r}
instrumental <- AnPrel(db$instrumentalness)
```
```{r}
#Statistiche di base
instrumental$stat
```
```{r}
#Distribuzione
instrumental$distr
```
```{r}
#Normalità
instrumental$qqnorm()
```
```{r}
#Stima intervallare di "strumentalità" media dal 1921 ad oggi (al 95%)
ICmedia(db$instrumentalness)
```
La quantità media di contenuto esclusivamente strumentale all'interno delle tracce, con un livello di confidenza del 95%, viene pertanto stimata scarsa, al massimo pari a circa il 16.3%.

###Analisi di "Liveness"
```{r}
live <- AnPrel(db$liveness)
```
```{r}
#Statistiche di base
live$stat
```
```{r}
#Distribuzione
live$distr
```
```{r}
#Normalità
live$qqnorm()
```
```{r}
#Stima intervallare della presenza media di pubblico nella registrazione (al 95%)
ICmedia(db$liveness)
```
La stima della probabilità media di presenza di un'audience durante la registrazione del brano è, con confidenza al 95%, compresa fra circa il 20.6% e 20.8%.

###Analisi di "Loudness"
```{r}
loud <- AnPrel(db$loudness)
```
```{r}
#Statistiche di base
loud$stat
```
```{r}
#Distribuzione
loud$distr
```
```{r}
#Normalità
loud$qqnorm()
```
```{r}
#Stima intervallare del volume complessivo medio dal 1921 ad oggi (al 95%)
ICmedia(db$loudness)
```
Il volume complessivo medio viene stimato, con alfa a 0.05, tra circa i -11.4 decibel e -11.3 decibel

###Analisi di "Speechiness"
```{r}
speech <- AnPrel(db$speechiness)
```
```{r}
#Statistiche di base
speech$stat
```
```{r}
#Distribuzione
speech$distr
```
```{r}
#Normalità
speech$qqnorm()
```
```{r}
#Stima intervallare del volume complessivo medio dal 1921 ad oggi (al 95%)
ICmedia(db$speechiness)
```
La probabilità media di rilevare del parlato all'interno delle canzoni è, comprensibilmente, molto bassa, stimata con un livello di confidenza del 95% tra circa il 9.3% e il 9.5%.

###Analisi di "Tempo"
```{r}
t<- AnPrel(db$tempo)
```
```{r}
#Statistiche di base
t$stat
```
```{r}
#Distribuzione
t$distr
```
```{r}
#Normalità
t$qqnorm()
```
```{r}
#Stima intervallare dei bpm medi dal 1921 ad oggi (al 95%)
ICmedia(db$tempo)
```

###Analisi di "Valence"
```{r}
val<- AnPrel(db$valence)
```
```{r}
#Statistiche di base
val$stat
```
```{r}
#Distribuzione
val$distr
```
```{r}
#Normalità
val$qqnorm()
```
```{r}
#Stima intervallare della positività media trasmessa (al 95%)
ICmedia(db$valence)
```
\
Supponendo indipendenti le decadi, è possibile rintracciare una connessione fra il decennio in cui la traccia è stata pubblicata e il livello emotivo trasmesso?
```{r}
#Tabella a doppia entrata
table=table(db$decade, db$valence)
#Indice di connessione delle contingenze
chi=chisq.test(table) 
chi
```
Viene rifiutata l'ipotesi di indipendenza fra le due variabili.
```{r}
#Boxplot condizionato
ggplot(db, aes(x=decade, y=valence, group=decade)) +
  geom_boxplot()+
  xlab(label = "Decennio")+
  ylab(label = "Positività")+
  scale_x_continuous(breaks = scales::pretty_breaks(n = 11))
```
```{r}
#Test ANOVA per l'uguaglianza delle medie
summary(aov(valence ~ as.factor(decade), db))
```
\
È poi possibile che la positività trasmessa possa dipendere statisticamente dalla tonalità?
```{r}
#Test chi quadro
chisq.test(table(db$mode, db$valence)) 
```
Viene rifiutata l'ipotesi di indipendenza fra le due variabili.
```{r}
#Test ANOVA per l'uguaglianza delle medie
summary(aov(valence ~ as.factor(mode), db))
```
\
Infine, si valuta una connessione fra chiave globale della traccia e livello di positività:
```{r}
#Test chi quadro
chisq.test(table(db$key, db$valence)) 
```
Viene rifiutata l'ipotesi di indipendenza fra le due variabili.
```{r}
#Test ANOVA per l'uguaglianza delle medie
summary(aov(valence ~ as.factor(key), db))
```

###Analisi di "Popularity"
```{r}
pop<- AnPrel(db$popularity)
```
```{r}
#Statistiche di base
pop$stat
```
```{r}
#Distribuzione
pop$distr
```
```{r}
#Normalità
pop$qqnorm()
```

##Correlazioni lineari
Verranno stimati i coefficienti di correlazione di Pearson per tutte le possibili coppie di variabili quantitative e verrà effettuato il corrispettivo test con livello di confidenza fissato al 95% per valutare la significatività statistica delle correlazioni più interessanti.
```{r}
#Matrice di correlazione
db_num <- db[ , !(colnames(db) %in% c("key","mode","explicit","decade")), drop=FALSE]
cormat <- round(cor(db_num),2)
melted_cormat <- melt(cormat)
reorder_cormat <- function(cormat){
  dd <- as.dist((1-cormat)/2)
  hc <- hclust(dd)
  cormat <-cormat[hc$order, hc$order]
}
get_upper_tri <- function(cormat){
    cormat[lower.tri(cormat)]<- NA
    return(cormat)
}
cormat <- reorder_cormat(cormat)
upper_tri <- get_upper_tri(cormat)
melted_cormat <- melt(upper_tri, na.rm = TRUE)
#Heatmap
ggheatmap <- ggplot(melted_cormat, aes(Var2, Var1, fill = value))+
  geom_tile(color = "white")+
  scale_fill_gradient2(low = "blue", high = "red", mid = "white",midpoint = 0, limit = c(-1,1), space = "Lab",name="Pearson\nCorrelation") +
  theme_minimal()+ 
  theme(axis.text.x = element_text(angle = 45, vjust = 1,size = 9, hjust = 1))+
  coord_fixed()+ 
  geom_text(aes(Var2, Var1, label = value), color = "black", size = 3)+
  theme(
  axis.title.x = element_blank(),
  axis.title.y = element_blank(),
  panel.grid.major = element_blank(),
  panel.border = element_blank(),
  panel.background = element_blank(),
  axis.ticks = element_blank(),
  legend.justification = c(1, 0),
  legend.position = c(0.6, 0.7),
  legend.direction = "horizontal")+
  guides(fill = guide_colorbar(barwidth = 7, barheight = 1,title.position = "top", title.hjust = 0.5))
ggheatmap
```
```{r}
rhotest(db$danceability,db$valence)
```
```{r}
rhotest(db$popularity,db$acousticness)
```
```{r}
rhotest(db$popularity,db$energy)
```
```{r}
rhotest(db$popularity,db$loudness)
```
```{r}
rhotest(db$energy,db$loudness)
```
```{r}
rhotest(db$energy,db$acousticness)
```
```{r}
rhotest(db$loudness,db$acousticness)
```
```{r}
rhotest(db$loudness,db$instrumentalness)
```
```{r}
rhotest(db$danceability,db$tempo)
```
```{r}
rhotest(db$liveness,db$valence)
```

##Regressione semplice
Poiché la differenza di scala è talvolta eccessiva, le stime dei coefficienti di regressione non possono spesso essere confrontate. Perciò, è utile mappare i valori di ogni variabile fra 0 e 1 senza modificarne la forma della distribuzione, sfruttando il massimo e il minimo.
```{r}
#Mappatura fra 0 e 1
ScaleMinMax <- function(x){return((x-min(x))/(max(x)-min(x)))}
dbs <- db
for (c in c("acousticness","danceability","duration_ms","energy","instrumentalness","liveness","loudness","popularity","speechiness","tempo","valence" )){
 dbs[c] <- ScaleMinMax(dbs[c]) 
}
```
Le variabili qualitative vengono convertite in tipo "factor", in modo che ogni loro modalità possa essere considerata dal modello come una colonna dummy.
```{r}
dbs[,c("decade","key","mode","explicit")] <-lapply(dbs[,c("decade","key","mode","explicit")],as.factor)
```
```{r}
#1) Popolarità ~ Acusticità
mod<-lm(popularity~acousticness,dbs)
summary(mod)
```
```{r}
#2) Popolarità ~ Chiave
dbs$key<-mapvalues(db$key,c(0,1,2,3,4,5,6,7,8,9,10,11),c("Do","Do♯","Re","Re♯","Mi","Fa","Fa♯","Sol","Sol♯","La","La♯","Si"))
summary(lm(popularity~key,dbs)) 
```
```{r}
#3) Popolarità ~ Decennio
summary(lm(popularity~decade,dbs))
```    
```{r}
#4) Popolarità ~ Esplicito
summary(lm(popularity~explicit,dbs))
```   
```{r}
#5) Popolarità ~ Tonalità
summary(lm(popularity~mode,dbs))
```  

##Regressione multipla per la previsione della popolarità
```{r}
#Modello multivariato con le variabili numeriche
mod<-lm(popularity~acousticness+danceability+duration_ms+energy+instrumentalness+liveness+loudness+speechiness+tempo+valence,dbs)
summary(mod)
```  
```{r}
#Analisi dei residui
g<-ggplot(augment(mod), aes(x = .fitted, y = .resid)) + geom_point()+xlab(label="Valori stimati")+ylab(label="Residui")
g
#Normal QQ-Plot dei residui
res_stand<-rstandard(mod)
qqnorm(res_stand,ylab="Residui standardizzati",xlab="Quantili normali",main="") 
qqline(rstandard(mod))
```
I residui appiono omoschedastici e i loro quantili hanno sufficiente corrispondenza con quelli propri della distribuzione Normale.
```{r}
#Calcolo del VIF
mod<-lm(popularity~acousticness+danceability+energy+instrumentalness+liveness+loudness+speechiness+tempo+valence,dbs)
VIF<-vif(mod)
sqrt(VIF)>2
```
Energy risulta affetto da un moderato problema di collinearità: poichè la radice del proprio valore VIF è pari a circa 2.2 - oltre la soglia imposta di 2 -, significa che l'errore standard associato al proprio coefficiente di regressione è 2.2 volte più grande del caso in cui "energy" fosse incorrelato con gli altri predittori.
```{r}
#Modello delle variabili quantitative senza energy
mod1<-lm(popularity~acousticness+danceability+instrumentalness+liveness+loudness+speechiness+tempo+valence,dbs)
summary(mod1)
```
```{r}
#Aggiunta delle variabili qualitative
mod2<-lm(popularity~acousticness+danceability+instrumentalness+liveness+loudness+speechiness+tempo+valence+explicit+key+mode+decade,dbs)
summary(mod2)
```
```{r}
#Calcolo del VIF
VIF<-vif(mod2)
VIF
```
Non vi sono più problemi di multicollinearità.





-valence~key, mode, decade



