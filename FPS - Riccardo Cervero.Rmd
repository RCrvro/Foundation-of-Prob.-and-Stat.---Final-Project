---
title: "Progetto di FP&S: Spotify Top Tracks Dataset"
author: "Riccardo Cervero"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

#Progetto di FP&S: Spotify Top Tracks Dataset
```{r}
##Caricamento pacchetti
library(plyr)
library(dplyr)
library(purrr)
library(ggplot2)
library(memisc)
library(e1071)
library(EnvStats)
library(reshape2)
library(car)
library(broom)

##Funzioni

#Calcolo della moda
moda <- function(x) {return(unique(x)[which.max(tabulate(match(x, unique(x))))])}

#Calcolo dell'indice di Gini normalizzato
G_normalizzato <- function(x){
  G=1-sum((table(x)/length(x))^2)
  n=length(unique(x))
  return(G*(n/(n-1)))
}

#Raggruppamento delle osservazioni per decenni
to_decade <- function(v){return(v-v%%10)}

#Calcolo del coefficiente di variazione
cv <- function(x){return(sd(x)/abs(mean(x)))}

#Calcolo della simmetria
m3 <- function(x){return(skewness(x,na.rm=T))}

#Calcolo della curtosi
m4 <- function(x){return(kurtosis(x,na.rm=T,method="moment",excess=F))}


#Analisi preliminare di una qualsiasi variabile numerica
AnPrel <- function(col) {
  
  #Statistiche preliminari
  s<-summary(col)
  stat <- c()
  for(i in 1:6) {stat<-c(stat,s[[i]])}
  #Moda
  m<-moda(col)
  #Varianza
  v<-var(col)
  #Coefficiente di variazione
  ccv<-cv(col)
  #Asimmetria
  as<-m3(col)
  if_Z <- function(){if(as==0){return("simmetrica")}else if(as>0){return("asimmetrica positiva")}else if(as<0){return("asimmetrica negativa")}}
  #Curtosi
  cu<-m4(col)
  if_C <- function(){if(cu==3){return("normale.")}else if(cu>3){return("leptocurtica.")}else if(cu<3){return("platicurtica.")}}
  
  stat<-c(stat,m,v,ccv,as,cu)
  indici <- c("Minimo","1o Qu.","Mediana","Media","3o Qu.","Massimo","Moda","Varianza","CdV","Asimmetria","Curtosi")
  stat <- data.frame(cbind(indici,stat))
  names(stat) <- c("Statistica","Valore")
  
  #Grafico della distribuzione
  if((typeof(col)=="double")||(col=db$duration_ms)){
    g<-ggplot(db, aes(x=col))+
      geom_histogram(binwidth = 0.01, color= "red", fill="white")+
      geom_vline(aes(xintercept=mean(col)),color="blue", linetype="dashed", size=0.5)+
      geom_vline(aes(xintercept=median(col)),color="green", linetype="dashed", size=0.5)+
      ylab(label="")+
      xlab(label=substring(deparse(substitute(col)), 4))+
      labs(title=paste("Distribuzione di frequenza di",substring(deparse(substitute(col)), 4)),caption="Le linee verticali tratteggiate corrispondono a media (in blue) e mediana (in verde).")
           } else if(typeof(col)=="integer"){
             g<-ggplot(db, aes(x=col))+
               geom_bar(binwidth = 0.01, color= "red", fill="white")+
               geom_vline(aes(xintercept=mean(col)),color="blue",linetype="dashed", size=0.5)+
               geom_vline(aes(xintercept=median(col)),color="green", linetype="dashed", size=0.5)+
               ylab(label="")+
               xlab(label=substring(deparse(substitute(col)), 4))+
               labs(title=paste("Distribuzione di frequenza di",substring(deparse(substitute(col)), 4)),caption="Le linee verticali tratteggiate corrispondono a media (in blue) e mediana (in verde).")
           }
  
  print(paste("La distribuzione Ã¨",if_Z(),"e",if_C()))
  return(list("stat"=stat,
              "distr"=g,
              "qqnorm"=function(){
    qqnorm(col)
    qqline(col)
  }))
}


#Funzione per inferenza della media di una v quantitativa
ICmedia <- function(col,l=0.95){
  n <- nrow(db)
  mu <- mean(col)
  sds <- sd(col)
  E <- qnorm(l+(1-l)/2)*sds/sqrt(n)
  return(c(mu-E, mu+E))
}

#Funzione per il test della correlazione lineare di Pearson (95%)
rhotest<-function(x,y){
  r<-cor.test(x,y,method="pearson")
  if(r$p.value>0.05){print("H0 accettata")}else{print("H0 rifiutata (corr. significativa)")}
  print(paste0("pvalue: ",r$p.value))
  print(paste0("rho: ",r$estimate))
}
```

Il database Ã¨ disponibile al link [kaggle/spotify-dataset](https://www.kaggle.com/yamaerenay/spotify-dataset-19212020-160k-tracks). La documentazione ufficiale Ã¨ disponibile al link [spotify/documentation](https://developer.spotify.com/documentation/web-api/reference/tracks/get-audio-features/).
```{r}
#Caricamento del dataset
db_ <- read.csv("/Users/riccardocervero/Desktop/DataScience/Materie/Foundation of Prob & Stats/Progetto FPS - Riccardo Cervero/SpotifyDb.csv")
```
```{r}
#Caricamento database ridotto
db <- read.csv("/Users/riccardocervero/Desktop/DataScience/Materie/Foundation of Prob & Stats/Progetto FPS - Riccardo Cervero/SpotifyRidotto.csv")
db <- db[ , !(colnames(db) %in% c("X")), drop=FALSE]
```
```{r}
#Dimensione del dataset
dim(db)
```
```{r}
#Variabili: nome, tipologia e numero di modalitÃ 
for (c in colnames(db)){
 print(paste0(c," : ",typeof(db[[c]]),", ",length(unique(db[[c]])))) 
}
```
* Acousticness Ã¨ misura numerica di confidenza con cui Ã¨ possibile definire "acustica" una traccia, compresa fra 0 e 1: se 1, indica massima certezza nell'affermare che il brano sia stato prodotto senza mezzi elettronici
* Artists Ã¨ la lista degli artisti a cui Ã¨ attribuita la produzione del brano 
* Danceability descrive il grado - misurato fra 0 e 1 - in cui la traccia puÃ² essere definita ballabile, come combinazione di vari elementi musicali, tra cui il tempo, la stabilitÃ  del ritmo, la forza del battito e la regolaritÃ  globale del brano: se 1, il pezzo raggiunge il massimo livello di ballabilitÃ 
* Duration_ms Ã¨ la durata in millisecondi
* Energy rappresenta la percentuale di intensitÃ  e attivitÃ  della traccia, sulla base di elementi percettivi quali sonoritÃ , timbro, ed entropia globale
* Explicit Ã¨ una variabile binaria che rileva la presenza - quando pari a 1 - o meno di contenuto esplicito
* Id Ã¨ l'identificatore primario della traccia 
* Instrumentalness misura, fra 0 e 1, l'assenza di contenuto vocale: piÃ¹ il valore si avvicina a 1, maggiore Ã¨ la confidenza con cui Ã¨ possibile definire "strumentale" la traccia
* Key registra la stima della chiave complessiva della traccia, codificata in un valore numerico compreso fra 0 (Do) e 11 (Si) 
* Liveness rileva la presenza di un pubblico udibile nella registrazione, definendone la probabilitÃ : se superiore a 0,8, fornisce una forte evidenza che la traccia sia stata registrata live
* Loudness Ã¨ il volume complessivo in decibel, fra -60 e circa 4
* Mode Ã¨ la variabile binaria di modalitÃ  del brano: 1 se maggiore e 0 se minore
* Name Ã¨ il nome del brano
* Release_date Ã¨ la data di uscita in formato aaa-mm-gg, aaaa-mm o aaaa 
* Speechiness indica la presenza di parlato: maggiore la somiglianza tra la traccia e un discorso - come nel caso del rap -, maggiore la vicinanza del valore a 1
* Tempo Ã¨ il ritmo misurato in battiti al minuto (bpm)
* Valence definisce il grado di positivitÃ  emotiva trasmessa dal brano, tra 0 e 1
* Year Ã¨ l'anno di uscita, dal 1921 al 2020
* Popularity Ã¨ una variabile intera compresa fra 0 e 100 che esprime il grado di popolaritÃ  del brano, calcolato a partire dal numero totale di riproduzioni su Spotify e da quanto sono recenti tali ascolti: in generale, tracce riprodotte molto frequente durante l'anno corrente avranno un valore di popolaritÃ  molto elevato
Quest'ultima verrÃ  considerata come principale variabile target nell'ambito della costruzione di modelli di regressione.

##Pre-Processing
```{r}
#Rimozione delle variabili inutili
vi <- c("artists","id","name")
db <- db[ , !(colnames(db) %in% vi), drop=FALSE]
```
```{r}
#Identificazione missing value
db[!complete.cases(db),]
#Missing values in "key"
any(db$key==-1)
```
```{r}
##Uniformare "release_date"
#Conta i formati
date_format <- c()
for(i in 1:length(release_date)) {
  if(!((class(try(as.Date(release_date[i], format= "%Y-%m-%d")))=="try-error")||(is.na(try(as.Date(release_date[i], format= "%Y-%m-%d")))))) {
  date_format <- c(date_format,"YMD")
} else if(!((class(try(as.Date(release_date[i], format= "%Y-%m")))=="try-error")||(is.na(try(as.Date(release_date[i], format= "%Y-%m")))))) {
  date_format <- c(date_format,"YM")
  } else if(!((class(try(as.Date(release_date[i], format= "%Y")))=="try-error")||(is.na(try(as.Date(release_date[i], format= "%Y")))))) {
  date_format <- c(date_format,"Y")
  }
}

table(date_format)
100*table(date_format)/length(date_format)
```

##Analisi delle variabili qualitative

###Analisi di "Year"
```{r}
#Tabella di frequenza
print("Frequenze relative:")
round(table(db$year)/length(db$year),4)
```
La variabile "year" Ã¨ multimodale, quindi non ha senso calcolarne la moda.
```{r}
#Indice di Gini
print("Indice di Gini normalizzato:")
G_normalizzato(db$year)
```
La mutabilitÃ  del fenomeno tende ad essere massima.
```{r}
#Raggruppamento in decenni
db$decade <- unlist(lapply(db$year,to_decade))
db <- db[ , !(colnames(db) %in% c("release_date","year")), drop=FALSE]
#Tabella di frequenza
print("Frequenze relative:")
round(table(db$decade)/length(db$decade),4)
```
```{r}
#PieChart dei decenni
y <- c()
for(i in 1:length(unique(db$decade))) {y<-c(y,table(db$decade)[[i]])}
data <- data.frame(Decennio=as.factor(unique(db$decade)),value=y)
data$label <- scales::percent(data$value/sum(data$value))
ggplot(data, aes(x="", y=value, fill=Decennio)) +
  geom_bar(stat="identity", width=1) +
  coord_polar("y", start=0)+
  theme_void()
```
```{r}
#Tabella a doppia entrata
table=table(db$decade, db$popularity)
#Indice di connessione delle contingenze
chi=chisq.test(table) 
chi
```
Viene rifiutata l'ipotesi di indipendenza fra le due variabili.
```{r}
#Boxplot condizionato
ggplot(db, aes(x=db$decade, y=db$popularity, group=db$decade)) + 
  geom_boxplot()+
  xlab(label = "Decennio")+
  ylab(label = "PopolaritÃ ")+
  scale_x_continuous(breaks = scales::pretty_breaks(n = 11))
```
```{r}
#Test ANOVA per l'uguaglianza delle medie
summary(aov(popularity ~ as.factor(decade), db))
```


###Analisi di "Explicit"
```{r}
print("Frequenze relative:")
round(table(db$explicit)/length(db$explicit),4)
```
```{r}
#Indice di Gini
print("Indice di Gini normalizzato:")
G_normalizzato(db$explicit)
```
L'eterogeneitÃ  del fenomeno Ã¨ ovviamente molto bassa.
```{r}
#PieChart di "explicit"
expl <- mapvalues(db$explicit,c(1,0),c("SÃ¬","No"))
y <- c()
for(i in 1:length(unique(expl))) {y<-c(y,table(expl)[[i]])}
data <- data.frame(Esplicito=as.factor(unique(expl)),value=y)
data$label <- scales::percent(data$value/sum(data$value))
ggplot(data, aes(x="", y=value, fill=Esplicito)) +
  geom_bar(stat="identity", width=1) +
  coord_polar("y", start=0)+
  theme_void()
```
```{r}
#Stima intervallare sulla proporzione di contenuto esplicito (con ð›¼=5%)
p <- unlist(table(db$explicit)/length(db$explicit))[[2]] #Freq relativa di contenuto esplicito
p0 <- unlist(table(db$explicit)/length(db$explicit))[[1]] #Freq relativa di contenuto non esplicito
n <- nrow(db) #Dimensione del campione
l <- 0.95   #Livello di confidenza
c <- l+(1-l)/2  
SE <- sqrt(p*(1-p)/n) #Deviazione standard di p 
E  <- qnorm(c)*SE
IC <- p+c(-E,E) #intervallo di confidenza per p (esplicito)
IC0 <- p0+c(-E,E) #intervallo di confidenza per p (non esplicito)
print(paste0("IC della proporzione di contenuto eplicito:  (",IC[1],", ",IC[2],")"))
print(paste0("IC della proporzione di contenuto non eplicito:  (",IC0[1],", ",IC0[2],")"))
```
```{r}
#Tabella a doppia entrata
table=table(db$explicit, db$popularity)
#Indice di connessione delle contingenze
chi=chisq.test(table) 
chi
```
Viene rifiutata l'ipotesi di indipendenza fra le due variabili.
```{r}
#Boxplot condizionato
ggplot(db, aes(x=mapvalues(db$explicit,c(1,0),c("SÃ¬","No")), y=db$popularity, group=mapvalues(db$explicit,c(1,0),c("SÃ¬","No")))) + 
  geom_boxplot()+
  xlab(label = "Esplicito")+
  ylab(label = "PopolaritÃ ")
```
```{r}
#Test ANOVA per l'uguaglianza delle medie
summary(aov(popularity ~ as.factor(explicit), db))
```

###Analisi di "Mode"
```{r}
print("Frequenze relative:")
round(table(db$mode)/length(db$mode),4)
```
```{r}
#Indice di Gini
print("Indice di Gini normalizzato:")
G_normalizzato(db$mode)
```
L'eterogeneitÃ  del fenomeno Ã¨ abbastanza elevata.
```{r}
#PieChart di "mode"
expl <- mapvalues(db$mode,c(1,0),c("Maggiore","Minore"))
y <- c()
for(i in 1:length(unique(expl))) {y<-c(y,table(expl)[[i]])}
data <- data.frame(ModalitÃ =as.factor(unique(expl)),value=y)
data$label <- scales::percent(data$value/sum(data$value))
ggplot(data, aes(x="", y=value, fill=ModalitÃ )) +
  geom_bar(stat="identity", width=1) +
  coord_polar("y", start=0)+
  theme_void()
```
```{r}
#Stima intervallare sulla proporzione della modalitÃ  (con ð›¼=5%)
p <- unlist(table(db$mode)/length(db$mode))[[2]] #Freq relativa di tonalitÃ  "major"
p0 <- unlist(table(db$mode)/length(db$mode))[[1]] #Freq relativa di tonalitÃ  "minor"
n <- nrow(db) #Dimensione del campione
l <- 0.95   #Livello di confidenza
c <- l+(1-l)/2  
SE <- sqrt(p*(1-p)/n) #Deviazione standard di p 
E  <- qnorm(c)*SE
IC <- p+c(-E,E) #intervallo di confidenza per p di "major"
IC0 <- p0+c(-E,E) #intervallo di confidenza per p di "minor"
print(paste0("IC della proporzione di tonalitÃ  maggiore:  (",IC[1],", ",IC[2],")"))
print(paste0("IC della proporzione di tonalitÃ  minore:  (",IC0[1],", ",IC0[2],")"))
```
```{r}
#Tabella a doppia entrata
table=table(db$mode, db$popularity)
#Indice di connessione delle contingenze
chi=chisq.test(table) 
chi
```
Viene rifiutata l'ipotesi di indipendenza fra le due variabili.
```{r}
#Boxplot condizionato
ggplot(db, aes(x=mapvalues(db$mode,c(1,0),c("Maggiore","Minore")), y=db$popularity, group=mapvalues(db$mode,c(1,0),c("Maggiore","Minore")))) +
  geom_boxplot()+
  xlab(label = "ModalitÃ ")+
  ylab(label = "PopolaritÃ ")
```
```{r}
#Test ANOVA per l'uguaglianza delle medie
summary(aov(popularity ~ as.factor(mode), db))
```

###Analisi di "Key"
```{r}
#Tabella di frequenza
print("Frequenze relative:")
round(table(db$key)/length(db$key),4)
#Moda
print("Moda:")
moda(db$key)
```
```{r}
#Indice di Gini
print("Indice di Gini normalizzato:")
G_normalizzato(db$key)
```
Il fenomeno Ã¨ estremamente eterogeneo.
```{r}
#PieChart di "key"
expl <- mapvalues(db$key,c(0,1,2,3,4,5,6,7,8,9,10,11),c("Do","Doâ™¯","Re","Reâ™¯","Mi","Fa","Faâ™¯","Sol","Solâ™¯","La","Laâ™¯","Si"))
y <- c()
for(i in 1:length(unique(expl))) {y<-c(y,table(expl)[[i]])}
data <- data.frame(Chiave=as.factor(unique(expl)),value=y)
data$label <- scales::percent(data$value/sum(data$value))
ggplot(data, aes(x="", y=value, fill=Chiave)) +
  geom_bar(stat="identity", width=1) +
  coord_polar("y", start=0)+
  theme_void()
```
```{r}
#Stima intervallare sulla proporzione di Do (con ð›¼=5%)
p <- unlist(table(db$key)/length(db$key))[[1]] #Frequenza relativa di Do
n <- nrow(db) #Dimensione del campione
l <- 0.95   #Livello di confidenza
c <- l+(1-l)/2  
SE <- sqrt(p*(1-p)/n) #Deviazione standard di p 
E  <- qnorm(c)*SE
IC <- p+c(-E,E) #intervallo di confidenza per p di "major"
print(paste0("IC della proporzione di tracce in Do:  (",IC[1],", ",IC[2],")"))
```
```{r}
#Do puÃ² essere stimata, con confidenza al 95%, come chiave piÃ¹ frequente?
ICp <- function(k){
  p <- unlist(table(db$key)/length(db$key))[[k]]
  n <- nrow(db)
  SE <- sqrt(p*(1-p)/n)
  E  <- qnorm(0.975)*SE
  IC <- p+c(-E,E)
  if(IC[2]>=0.124951684177052){print(paste0(k-1,": TRUE"))}else{print(paste0(k-1,": IC minore rispetto alla classe 'Do'"))}
}
for(k in 2:12){ICp(k)}
```
```{r}
#Tabella a doppia entrata
table=table(db$key, db$popularity)
#Indice di connessione delle contingenze
chi=chisq.test(table) 
chi
```
Viene rifiutata l'ipotesi di indipendenza fra le due variabili.
```{r}
#Boxplot condizionato
ggplot(db, aes(x=mapvalues(db$key,c(0,1,2,3,4,5,6,7,8,9,10,11),c("Do","Doâ™¯","Re","Reâ™¯","Mi","Fa","Faâ™¯","Sol","Solâ™¯","La","Laâ™¯","Si")), y=db$popularity, group=mapvalues(db$key,c(0,1,2,3,4,5,6,7,8,9,10,11),c("Do","Doâ™¯","Re","Reâ™¯","Mi","Fa","Faâ™¯","Sol","Solâ™¯","La","Laâ™¯","Si")))) +
  geom_boxplot()+
  xlab(label = "Chiave")+
  ylab(label = "PopolaritÃ ")
```
```{r}
#Test ANOVA per l'uguaglianza delle medie
summary(aov(popularity ~ as.factor(key), db))
```

##Analisi delle variabili quantitative

###Analisi di "Acousticness"
```{r}
acoustic <- AnPrel(db$acousticness)
```
```{r}
#Statistiche di base
acoustic$stat
```
```{r}
#Distribuzione
acoustic$distr
```
```{r}
#NormalitÃ 
acoustic$qqnorm()
```
```{r}
#Stima intervallare dell'acusticitÃ  media dal 1921 ad oggi (al 95%)
ICmedia(db$acousticness)
```
I dati si riferiscono pertanto a tracce con una probabilitÃ  media di essere completamente acustiche - stimata con confidenza al 95% - inferiore rispetto alla probabilitÃ  media di includere strumenti elettronici, poichÃ¨ l'intervallo di confidenza di "acousticness" ha estremo superiore inferiore a 0.5.

###Analisi di "Danceability"
```{r}
dance <- AnPrel(db$danceability)
```
```{r}
#Statistiche di base
dance$stat
```
```{r}
#Distribuzione
dance$distr
```
```{r}
#NormalitÃ 
dance$qqnorm()
```
```{r}
#Stima intervallare della ballabilitÃ  media dal 1921 ad oggi (al 95%)
ICmedia(db$danceability)
```

###Analisi di "Duration_ms"
```{r}
duration <- AnPrel(db$duration_ms)
```
```{r}
#Statistiche di base
duration$stat
```
```{r,include=FALSE,eval=FALSE}
#Distribuzione
duration$distr
```
```{r,include=FALSE,eval=FALSE}
#NormalitÃ 
duration$qqnorm()
```
```{r}
#Stima intervallare della durata media dal 1921 ad oggi (al 95%)
ICmedia(db$duration_ms)
```
La stima - con livello di confidenza al 95% - della durata media dei brani Ã¨ compresa fra circa 3 minuti e 51 secondi e 3 minuti e 52 secondi.

###Analisi di "Energy"
```{r}
ener <- AnPrel(db$energy)
```
```{r}
#Statistiche di base
ener$stat
```
```{r}
#Distribuzione
ener$distr
```
```{r}
#NormalitÃ 
ener$qqnorm()
```
```{r}
#Stima intervallare dell'energia media dal 1921 ad oggi (al 95%)
ICmedia(db$energy)
```

###Analisi di "Instrumentalness"
```{r}
instrumental <- AnPrel(db$instrumentalness)
```
```{r}
#Statistiche di base
instrumental$stat
```
```{r}
#Distribuzione
instrumental$distr
```
```{r}
#NormalitÃ 
instrumental$qqnorm()
```
```{r}
#Stima intervallare di "strumentalitÃ " media dal 1921 ad oggi (al 95%)
ICmedia(db$instrumentalness)
```
La quantitÃ  media di contenuto esclusivamente strumentale all'interno delle tracce, con un livello di confidenza del 95%, viene pertanto stimata scarsa, al massimo pari a circa il 16.3%.

###Analisi di "Liveness"
```{r}
live <- AnPrel(db$liveness)
```
```{r}
#Statistiche di base
live$stat
```
```{r}
#Distribuzione
live$distr
```
```{r}
#NormalitÃ 
live$qqnorm()
```
```{r}
#Stima intervallare della presenza media di pubblico nella registrazione (al 95%)
ICmedia(db$liveness)
```
La stima della probabilitÃ  media di presenza di un'audience durante la registrazione del brano Ã¨, con confidenza al 95%, compresa fra circa il 20.6% e 20.8%.

###Analisi di "Loudness"
```{r}
loud <- AnPrel(db$loudness)
```
```{r}
#Statistiche di base
loud$stat
```
```{r}
#Distribuzione
loud$distr
```
```{r}
#NormalitÃ 
loud$qqnorm()
```
```{r}
#Stima intervallare del volume complessivo medio dal 1921 ad oggi (al 95%)
ICmedia(db$loudness)
```
Il volume complessivo medio viene stimato, con alfa a 0.05, tra circa i -11.4 decibel e -11.3 decibel

###Analisi di "Speechiness"
```{r}
speech <- AnPrel(db$speechiness)
```
```{r}
#Statistiche di base
speech$stat
```
```{r}
#Distribuzione
speech$distr
```
```{r}
#NormalitÃ 
speech$qqnorm()
```
```{r}
#Stima intervallare del volume complessivo medio dal 1921 ad oggi (al 95%)
ICmedia(db$speechiness)
```
La probabilitÃ  media di rilevare del parlato all'interno delle canzoni Ã¨, comprensibilmente, molto bassa, stimata con un livello di confidenza del 95% tra circa il 9.3% e il 9.5%.

###Analisi di "Tempo"
```{r}
t<- AnPrel(db$tempo)
```
```{r}
#Statistiche di base
t$stat
```
```{r}
#Distribuzione
t$distr
```
```{r}
#NormalitÃ 
t$qqnorm()
```
```{r}
#Stima intervallare dei bpm medi dal 1921 ad oggi (al 95%)
ICmedia(db$tempo)
```

###Analisi di "Valence"
```{r}
val<- AnPrel(db$valence)
```
```{r}
#Statistiche di base
val$stat
```
```{r}
#Distribuzione
val$distr
```
```{r}
#NormalitÃ 
val$qqnorm()
```
```{r}
#Stima intervallare della positivitÃ  media trasmessa (al 95%)
ICmedia(db$valence)
```
\
Supponendo indipendenti le decadi, Ã¨ possibile rintracciare una connessione fra il decennio in cui la traccia Ã¨ stata pubblicata e il livello emotivo trasmesso?
```{r}
#Tabella a doppia entrata
table=table(db$decade, db$valence)
#Indice di connessione delle contingenze
chi=chisq.test(table) 
chi
```
Viene rifiutata l'ipotesi di indipendenza fra le due variabili.
```{r}
#Boxplot condizionato
ggplot(db, aes(x=decade, y=valence, group=decade)) +
  geom_boxplot()+
  xlab(label = "Decennio")+
  ylab(label = "PositivitÃ ")+
  scale_x_continuous(breaks = scales::pretty_breaks(n = 11))
```
```{r}
#Test ANOVA per l'uguaglianza delle medie
summary(aov(valence ~ as.factor(decade), db))
```
\
Ãˆ poi possibile che la positivitÃ  trasmessa possa dipendere statisticamente dalla tonalitÃ ?
```{r}
#Test chi quadro
chisq.test(table(db$mode, db$valence)) 
```
Viene rifiutata l'ipotesi di indipendenza fra le due variabili.
```{r}
#Test ANOVA per l'uguaglianza delle medie
summary(aov(valence ~ as.factor(mode), db))
```
\
Infine, si valuta una connessione fra chiave globale della traccia e livello di positivitÃ :
```{r}
#Test chi quadro
chisq.test(table(db$key, db$valence)) 
```
Viene rifiutata l'ipotesi di indipendenza fra le due variabili.
```{r}
#Test ANOVA per l'uguaglianza delle medie
summary(aov(valence ~ as.factor(key), db))
```

###Analisi di "Popularity"
```{r}
pop<- AnPrel(db$popularity)
```
```{r}
#Statistiche di base
pop$stat
```
```{r}
#Distribuzione
pop$distr
```
```{r}
#NormalitÃ 
pop$qqnorm()
```

##Correlazioni lineari
Verranno stimati i coefficienti di correlazione di Pearson per tutte le possibili coppie di variabili quantitative e verrÃ  effettuato il corrispettivo test con livello di confidenza fissato al 95% per valutare la significativitÃ  statistica delle correlazioni piÃ¹ interessanti.
```{r}
#Matrice di correlazione
db_num <- db[ , !(colnames(db) %in% c("key","mode","explicit","decade")), drop=FALSE]
cormat <- round(cor(db_num),2)
melted_cormat <- melt(cormat)
reorder_cormat <- function(cormat){
  dd <- as.dist((1-cormat)/2)
  hc <- hclust(dd)
  cormat <-cormat[hc$order, hc$order]
}
get_upper_tri <- function(cormat){
    cormat[lower.tri(cormat)]<- NA
    return(cormat)
}
cormat <- reorder_cormat(cormat)
upper_tri <- get_upper_tri(cormat)
melted_cormat <- melt(upper_tri, na.rm = TRUE)
#Heatmap
ggheatmap <- ggplot(melted_cormat, aes(Var2, Var1, fill = value))+
  geom_tile(color = "white")+
  scale_fill_gradient2(low = "blue", high = "red", mid = "white",midpoint = 0, limit = c(-1,1), space = "Lab",name="Pearson\nCorrelation") +
  theme_minimal()+ 
  theme(axis.text.x = element_text(angle = 45, vjust = 1,size = 9, hjust = 1))+
  coord_fixed()+ 
  geom_text(aes(Var2, Var1, label = value), color = "black", size = 3)+
  theme(
  axis.title.x = element_blank(),
  axis.title.y = element_blank(),
  panel.grid.major = element_blank(),
  panel.border = element_blank(),
  panel.background = element_blank(),
  axis.ticks = element_blank(),
  legend.justification = c(1, 0),
  legend.position = c(0.6, 0.7),
  legend.direction = "horizontal")+
  guides(fill = guide_colorbar(barwidth = 7, barheight = 1,title.position = "top", title.hjust = 0.5))
ggheatmap
```
```{r}
rhotest(db$danceability,db$valence)
```
```{r}
rhotest(db$popularity,db$acousticness)
```
```{r}
rhotest(db$popularity,db$energy)
```
```{r}
rhotest(db$popularity,db$loudness)
```
```{r}
rhotest(db$energy,db$loudness)
```
```{r}
rhotest(db$energy,db$acousticness)
```
```{r}
rhotest(db$loudness,db$acousticness)
```
```{r}
rhotest(db$loudness,db$instrumentalness)
```
```{r}
rhotest(db$danceability,db$tempo)
```
```{r}
rhotest(db$liveness,db$valence)
```

##Regressione semplice
PoichÃ© la differenza di scala Ã¨ talvolta eccessiva, le stime dei coefficienti di regressione non possono spesso essere confrontate. PerciÃ², Ã¨ utile mappare i valori di ogni variabile fra 0 e 1 senza modificarne la forma della distribuzione, sfruttando il massimo e il minimo.
```{r}
#Mappatura fra 0 e 1
ScaleMinMax <- function(x){return((x-min(x))/(max(x)-min(x)))}
dbs <- db
for (c in c("acousticness","danceability","duration_ms","energy","instrumentalness","liveness","loudness","popularity","speechiness","tempo","valence" )){
 dbs[c] <- ScaleMinMax(dbs[c]) 
}
```
Le variabili qualitative vengono convertite in tipo "factor", in modo che ogni loro modalitÃ  possa essere considerata dal modello come una colonna dummy.
```{r}
dbs[,c("decade","key","mode","explicit")] <-lapply(dbs[,c("decade","key","mode","explicit")],as.factor)
```
```{r}
#1) PopolaritÃ  ~ AcusticitÃ 
mod<-lm(popularity~acousticness,dbs)
summary(mod)
```
```{r}
#2) PopolaritÃ  ~ Chiave
dbs$key<-mapvalues(db$key,c(0,1,2,3,4,5,6,7,8,9,10,11),c("Do","Doâ™¯","Re","Reâ™¯","Mi","Fa","Faâ™¯","Sol","Solâ™¯","La","Laâ™¯","Si"))
summary(lm(popularity~key,dbs)) 
```
```{r}
#3) PopolaritÃ  ~ Decennio
summary(lm(popularity~decade,dbs))
```    
```{r}
#4) PopolaritÃ  ~ Esplicito
summary(lm(popularity~explicit,dbs))
```   
```{r}
#5) PopolaritÃ  ~ TonalitÃ 
summary(lm(popularity~mode,dbs))
```  

##Regressione multipla per la previsione della popolaritÃ 
```{r}
#Modello multivariato con le variabili numeriche
mod<-lm(popularity~acousticness+danceability+duration_ms+energy+instrumentalness+liveness+loudness+speechiness+tempo+valence,dbs)
summary(mod)
```  
```{r}
#Analisi dei residui
g<-ggplot(augment(mod), aes(x = .fitted, y = .resid)) + geom_point()+xlab(label="Valori stimati")+ylab(label="Residui")
g
#Normal QQ-Plot dei residui
res_stand<-rstandard(mod)
qqnorm(res_stand,ylab="Residui standardizzati",xlab="Quantili normali",main="") 
qqline(rstandard(mod))
```
I residui appiono omoschedastici e i loro quantili hanno sufficiente corrispondenza con quelli propri della distribuzione Normale.
```{r}
#Calcolo del VIF
mod<-lm(popularity~acousticness+danceability+energy+instrumentalness+liveness+loudness+speechiness+tempo+valence,dbs)
VIF<-vif(mod)
sqrt(VIF)>2
```
Energy risulta affetto da un moderato problema di collinearitÃ : poichÃ¨ la radice del proprio valore VIF Ã¨ pari a circa 2.2 - oltre la soglia imposta di 2 -, significa che l'errore standard associato al proprio coefficiente di regressione Ã¨ 2.2 volte piÃ¹ grande del caso in cui "energy" fosse incorrelato con gli altri predittori.
```{r}
#Modello delle variabili quantitative senza energy
mod1<-lm(popularity~acousticness+danceability+instrumentalness+liveness+loudness+speechiness+tempo+valence,dbs)
summary(mod1)
```
```{r}
#Aggiunta delle variabili qualitative
mod2<-lm(popularity~acousticness+danceability+instrumentalness+liveness+loudness+speechiness+tempo+valence+explicit+key+mode+decade,dbs)
summary(mod2)
```
```{r}
#Calcolo del VIF
VIF<-vif(mod2)
VIF
```
Non vi sono piÃ¹ problemi di multicollinearitÃ .





-valence~key, mode, decade



